---
title: "Assignment Template"
author: "Dr Thomas Robinson and Dr Dan de Kadt"
date: "AT 2023"
output: html_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = FALSE) # actually set the global chunk options. 
library("jsonlite")
library("tidyverse")
library("DBI")
library("RSQLite")
```

```{r}
get_data <- function(url){
  data<- GET(url)
  
  data_parsed <- content(data, "parsed")
  
  return(data_parsed)
}

create_written_df_row <- function(element){
  new_row <- tibble(
    question_id = element$value$id,
    asking_member_id = element$value$askingMemberId,  
    asking_member_name = element$value$askingMember$name,
    asking_member_party = element$value$askingMember$party,
    asking_member_from = element$value$askingMember$memberFrom,
    answering_body_name = element$value$answeringBodyName
  )
  return(new_row)
}

create_oral_df_row <- function(element){
  new_row <- tibble(
    question_id = element$Id,
    asking_member_id = element$AskingMemberId,  
    asking_member_name = element$AskingMember$Name,
    asking_member_party = element$AskingMember$Party,
    asking_member_from = element$AskingMember$Constituency,
    answering_body_name = element$AnsweringBody
  )
  return(new_row)
}

get_written_data <- function(base_url, skip_records, take_records){
  url <- paste0(base_url, skip_records, take_records) #construct first request
  
  written_data <- get_data(url) #get first request
  
  written_list <- list() #create a new list
  
  written_list <- append(written_list, written_data$results) #append first request to the list
  
  num_requests <- ceiling(written_data$totalResults / 100) #calculate number of requests needed
  
  for (i in 1:num_requests){ #for each request in num_requests
    
    cat("Getting request ", i, " out of ", num_requests, "\n") #update user
    
    skip_records <- skip_records + 100 #update the skip number
    
    url <- paste0(base_url, skip_records, take_records) #update the url
    
    written_data <- get_data(url) #get current request
    
    written_list <- append(written_list, written_data$results) #append current request to the list
    
    #add a pause
    Sys.sleep(2)
  }
  
  results <- map_df(written_list, create_written_df_row) #construct df with needed data
  
  return(results)
}

get_oral_data <- function(base_url, skip_records, take_records){
  url <- paste0(base_url, skip_records, take_records) #construct first request
  
  oral_data <- get_data(url) #get first request
  
  oral_list <- list() #create a new list
  
  oral_list <- append(oral_list, oral_data$Response) #append first request to the list

  num_requests <- ceiling(oral_data$PagingInfo$GlobalTotal / 100) #calculate number of requests needed
  
  for (i in 1:num_requests){ #for each request in num_requests
    
    cat("Getting request ", i, " out of ", num_requests, "\n") #update user
    
    skip_records <- skip_records + 100 #update the skip number
    
    url <- paste0(base_url, skip_records, take_records) #update the url
    
    oral_data <- get_data(url) #get current request
    
    oral_list <- append(oral_list, oral_data$Response) #append current request to the list
    
    #add a pause
    Sys.sleep(2)
  }
  
  results <- map_df(oral_list, create_oral_df_row) #construct df with needed data
  
  return(results)
}
```


```{r}
#set the base url
base_url <- 'https://questions-statements-api.parliament.uk/api/writtenquestions/questions?tabledWhenFrom=2022-01-01&tabledWhenTo=2022-01-10&includeWithdrawn=true&expandMember=true&answeringBodies=17&answeringBodies=14&answeringBodies=214&answeringBodies=202&answeringBodies=29&house=Commons&skip='

#set the skip_records
skip_records <- 0

#set_take_records
take_records <- '&take=100'

written_df <- get_written_data(base_url,skip_records,take_records)

base_url <- 'https://oralquestionsandmotions-api.parliament.uk/oralquestions/list?parameters.answeringDateStart=2022-01-01&parameters.answeringDateEnd=2022-01-31&parameters.answeringBodyIds=17&parameters.answeringBodyIds=14&parameters.answeringBodyIds=214&parameters.answeringBodyIds=202&parameters.answeringBodyIds=29&parameters.skip='

skip_records <- 0

take_records <- '&parameters.take=100'

oral_df <- get_oral_data(base_url,skip_records,take_records)

all_qs <- rbind(written_df, oral_df)

all_qs_grouped <- all_qs %>%
  group_by(asking_member_id) %>%
  summarise(
    health_welfare_count = sum(answering_body_name %in% c("Department of Health and Social Care", "Department for Work and Pensions")),
    economic_count = sum(!answering_body_name %in% c("Department of Health and Social Care", "Department for Work and Pensions")),
    majority_health_welfare = ifelse(health_welfare_count > economic_count, TRUE,FALSE),
    majority_economic = ifelse(health_welfare_count < economic_count, TRUE,FALSE),
    no_majority = ifelse(health_welfare_count == economic_count, TRUE,FALSE)
  )

all_qs_processed <- left_join(all_qs_grouped, all_qs %>%
                       distinct(asking_member_id, .keep_all = TRUE), 
                       by = "asking_member_id") %>%
  select(c(asking_member_name, 
           asking_member_party, 
           asking_member_from, 
           majority_health_welfare, 
           majority_economic, 
           no_majority))

```

```{r}

datasets <- GET("http://www.nomisweb.co.uk/api/v01/dataset/def.sdmx.json?search=name-TS037*")

dataset_parsed<- content(datasets, "parsed")

for (i in seq_along(dataset_parsed$structure$keyfamilies$keyfamily)){
  print(dataset_parsed$structure$keyfamilies$keyfamily[[i]]$annotations$annotation[[11]]$annotationtext)
}

# get list options
health_options <- GET("http://www.nomisweb.co.uk/api/v01/dataset/NM_2055_1/geography.def.sdmx.json?")

options_parsed <- content(health_options, "parsed")

#get actual data
general_health <- GET("http://www.nomisweb.co.uk/api/v01/dataset/NM_2055_1.jsonstat.json?geography=641731929&measures=20301&c2021_health_6=5")

health_parsed <- content(general_health, "parsed")

#gender
#where they are from
```





This document contains the necessary commands and layout to meet the formatting requirements for MY472. You should use the template.Rmd file as the basis for your own answers to the assigned exercises.

## Formatting requirements

* You must present all results in full sentences, as you would in a report or academic piece of writing
  
  * If the exercise requires generating a table or figure, you should include at least one sentence introducing and explaining it. E.g. "The table below reports the counts of Wikipedia articles mentioning the LSE, by type of article."

* Unless stated otherwise, all code used to answer the exercises should be included as a code appendix at the end of the script. This formatting can be achieved by following the guidance in this template file.

* All code should be annotated with comments, to help the marker understand what you have done

* Your output should be replicable. Any result/table/figure that cannot be traced back to your code will not be marked

## Example of in-line figures without code

For those interested, we achieve the formatting requirements in two-steps: 1) in the `setup` chunk, we set `knitr::opts_chunk$set(echo = FALSE)` so that code is not included (echoed) by default in code chunks; 2) we add a specific chunk at the end of the file to collect and print *all* the code in the Rmarkdown file. Do not delete the final code chunk from the template!

For example, below we use a code chunk to generate random data and include a scatter plot in-line. The code used to generate this chart is only reported at the end of the document. 

```{r plot_example}
set.seed(89) # set a seed for R's psuedo-randomiser, for replicability.
x <- rnorm(100) # randomly draw 100 obs from normal distribution, save as object
y <- rnorm(100) 
plot(x,y) # two-way scatterplot using R's default plotting
```

In specific instances, however, you may be directed to report your code in-line (or you may want to do this to illustrate a specific point). In these cases, we can override the default behaviour by adding the chunk option `echo = TRUE` to a specific R chunk. When `echo=TRUE`, your code is presented in-line with any output displayed afterwards. The same code will also be included in the appendix at the bottom of the document (which is fine).

```{r echo_example, echo=TRUE}
# {[language] [chunk_name], [chunk_options]}
# here we use echo=TRUE to override our global options and make the chunk appear exactly here. 

print("This code chunk is visible in this section.")
```

## Appendix: All code in this assignment

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE} 
# this chunk generates the complete code appendix. 
# eval=FALSE tells R not to run (``evaluate'') the code here (it was already run before).
```
