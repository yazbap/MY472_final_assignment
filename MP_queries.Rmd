---
title: "Assignment Template"
author: "Dr Thomas Robinson and Dr Dan de Kadt"
date: "AT 2023"
output: html_document
---

```{r setup, include=FALSE} 
knitr::opts_chunk$set(echo = FALSE) # actually set the global chunk options. 
library("jsonlite")
library("tidyverse")
library("DBI")
library("RSQLite")
```

```{r}
get_data <- function(base_url, skip_records, take_records){
  url <- paste0(base_url, skip_records, take_records)
  data<- GET(url)
  
  data_parsed <- content(data, "parsed")
  
  return(data_parsed)
}
```


```{r}
#set the base url
base_url <- 'https://questions-statements-api.parliament.uk/api/writtenquestions/questions?tabledWhenFrom=2022-01-01&tabledWhenTo=2022-01-15&includeWithdrawn=true&expandMember=true&answeringBodies=17&answeringBodies=14&answeringBodies=214&answeringBodies=202&answeringBodies=29&house=Commons&skip='

#set the skip_records
skip_records <- 0

#set_take_records
take_records <- '&take=100'

#perform the first request
written_data <- get_data(base_url, 
                         skip_records, 
                         take_records)

#create a new list
written_list <- list()

written_list <- append(results_list, written_data$results)

#calculate the number of times we are going to need to make the request by using totalResults
#set this number as num_requests
num_requests <- ceiling(written_data$totalResults / 100)

#for each request in num_requests
for (i in 1:num_requests){
  
  #update user
  cat("Getting request ", i, " out of ", num_requests)
  
  #update the skip number
  skip_records <- skip_records + 100
  
  #update the url
  written_data <- get_data(base_url,
                           skip_records, 
                           take_records)
  
  written_list <- append(written_list, written_data$results)
  #add a pause
  Sys.sleep(2)
}

#construct the master df

written_df <- tibble(question_id = as.character(), 
                     asking_member_id = as.integer(),
                     asking_member_name = as.character(),
                     asking_member_party = as.character(),
                     asking_member_from = as.character(),
                     member_has_interest = as.character(),
                     answering_body_name = as.character())

for (i in seq_along(written_list)){ 
  # Create a new row
  new_row <- tibble(
    question_id = written_list[[i]]$value$id,
    asking_member_id = written_list[[i]]$value$askingMember$id,  
    asking_member_name = written_list[[i]]$value$askingMember$name,
    asking_member_party = written_list[[i]]$value$askingMember$party,
    asking_member_from = written_list[[i]]$value$askingMember$memberFrom,
    answering_body_name = written_list[[i]]$value$answeringBodyName
  )
  
  # Append the new row to the dataframe
  written_df <- rbind(written_df, new_row)

}
```

```{r}
base_url <- 'https://oralquestionsandmotions-api.parliament.uk/oralquestions/list?parameters.answeringDateStart=2022-01-01&parameters.answeringDateEnd=2022-01-31&parameters.answeringBodyIds=17&parameters.answeringBodyIds=14&parameters.answeringBodyIds=214&parameters.answeringBodyIds=202&parameters.answeringBodyIds=29&parameters.skip='

skip_records <- 0

take_records <- '&parameters.take=100'

oral_data <- get_data(base_url,
                      skip_records,
                      take_records)

#create a new list
oral_list <- list()

oral_list <- append(results_list, oral_data$results)

#calculate the number of times we are going to need to make the request by using totalResults
#set this number as num_requests
num_requests <- ceiling(oral_data$PagingInfo$GlobalTotal / 100)

for (i in 1:num_requests){
  
  #update user
  cat("Getting request ", i, " out of ", num_requests)
  
  #update the skip number
  skip_records <- skip_records + 100
  
  #update the url
  oral_data <- get_data(base_url,
                        skip_records,
                        take_records)
  
  oral_list <- append(oral_list, oral_data$Response)
  #add a pause
  Sys.sleep(2)
}

#construct the master df

for (i in seq_along(oral_list)){ 
  # Create a new row
  new_row <- tibble(
    question_id = oral_list[[i]]$value$id,
    asking_member_id = oral_list[[i]]$value$askingMember$id,  
    asking_member_name = oral_list[[i]]$value$askingMember$name,
    asking_member_party = oral_list[[i]]$value$askingMember$party,
    asking_member_from = oral_list[[i]]$value$askingMember$memberFrom,
    answering_body_name = oral_list[[i]]$value$answeringBodyName
  )
  
  # Append the new row to the dataframe
  written_df <- rbind(written_df, new_row)

}
```

```{r}
#gender
#where they are from
```



This document contains the necessary commands and layout to meet the formatting requirements for MY472. You should use the template.Rmd file as the basis for your own answers to the assigned exercises.

## Formatting requirements

* You must present all results in full sentences, as you would in a report or academic piece of writing
  
  * If the exercise requires generating a table or figure, you should include at least one sentence introducing and explaining it. E.g. "The table below reports the counts of Wikipedia articles mentioning the LSE, by type of article."

* Unless stated otherwise, all code used to answer the exercises should be included as a code appendix at the end of the script. This formatting can be achieved by following the guidance in this template file.

* All code should be annotated with comments, to help the marker understand what you have done

* Your output should be replicable. Any result/table/figure that cannot be traced back to your code will not be marked

## Example of in-line figures without code

For those interested, we achieve the formatting requirements in two-steps: 1) in the `setup` chunk, we set `knitr::opts_chunk$set(echo = FALSE)` so that code is not included (echoed) by default in code chunks; 2) we add a specific chunk at the end of the file to collect and print *all* the code in the Rmarkdown file. Do not delete the final code chunk from the template!

For example, below we use a code chunk to generate random data and include a scatter plot in-line. The code used to generate this chart is only reported at the end of the document. 

```{r plot_example}
set.seed(89) # set a seed for R's psuedo-randomiser, for replicability.
x <- rnorm(100) # randomly draw 100 obs from normal distribution, save as object
y <- rnorm(100) 
plot(x,y) # two-way scatterplot using R's default plotting
```

In specific instances, however, you may be directed to report your code in-line (or you may want to do this to illustrate a specific point). In these cases, we can override the default behaviour by adding the chunk option `echo = TRUE` to a specific R chunk. When `echo=TRUE`, your code is presented in-line with any output displayed afterwards. The same code will also be included in the appendix at the bottom of the document (which is fine).

```{r echo_example, echo=TRUE}
# {[language] [chunk_name], [chunk_options]}
# here we use echo=TRUE to override our global options and make the chunk appear exactly here. 

print("This code chunk is visible in this section.")
```

## Appendix: All code in this assignment

```{r ref.label=knitr::all_labels(), echo=TRUE, eval=FALSE} 
# this chunk generates the complete code appendix. 
# eval=FALSE tells R not to run (``evaluate'') the code here (it was already run before).
```
